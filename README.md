# 设计模式学习
运行本代码的方法： 
npm install -g ts-node
ts-node filename.ts

### 面向对象
- 以类和对象作为组织代码的基本单位，并实现封装、抽象、继承、多态四个特性
- 软件开发经历分析、设计和编码三个阶段
  - 面向对象分析（OOA) Object Oriented Analysis
  - 面向对象设计（OOD) Object Oriented Design
  - 面向对象编程（OOP） Object Oriented Programming

#### 抽象（Abstract）
- 抽象主要是隐藏方法的实现，让调用者只关系有哪些功能而不是关系功能的实现
- 抽象可以提高代码的可扩展性和维护性，修改实现不需要改变定义，可以减少代码的改动范围

#### 继承
- 继承的目的是为了复用
- 但是当继承过深的时候，可维护性和可读性就会变差，且子类和父类存在着耦合关系，修改父类的时候，子类会受到影响（所以宁组合、勿继承）

### 封装
定义： 封装就是把数据和方法封装起来
封装的好处： 
* 封装的目的是为了减少耦合，不该外部访问的的就不要让外部访问
* 有利于数据的接口权限管理
* 仅暴露有限的必要接口，提高类的易用性
权限修饰符：
* public ： 共有修饰符，可以在类内部或者类外使用 public 修饰的属性或方法（public 也是默认的权限修饰符）
* protected： 受保护的修饰符，可以在本类和子类中使用 protected 修饰的属性和方法
* private： 私有修饰符，只可以在类内部使用 private 修饰的属性和方法


#### 多态
定义： 多态是指相同的行为 表现得不一样
优点： 
- 实现面向接口编程
- 保持子类的开放性和灵活性，可以重写父类中的方法

## 设计原则
### 单一职责原则（Single responsibility principle) 比如 lodash 的工具方法
- 一个类或者模块只负责一个职责，如果功能特别复杂就进行拆分
- 单一职责可以降低类的复杂性，提高代码可读性，可维护性
- 当类代码行数过多，方法过多，功能太多，职责太杂的时候就要对类进行拆分
- 拆分不能过度，如果拆分过度就会损失内聚性和维护性

### 里氏替换原则 （Liskov Substitution Principle)
- 所有应用基类的地方必须能透明的使用其子类对象
- 子类能替换掉父类，使用者可能根本就不需要知道是父类还是子类，反之则不行
- 里氏替换原则是开闭原则的实现基础，程序设计的时候尽量使用积累定义及引用，运行时在决定使用哪个子类
- 里式替换原则可以提高代码的复用性，提高代码的可扩展性，也是增加了耦合性
- 相对于多态，这个原则是讲类应该如何设计，子类如果违反了父类的功能则表示违反了里氏替换原则
总结： 子类能替换父类（尽可能的使用父类或者抽象类)，子类不能违反父类的功能

### 依赖倒转原则（Dependence Inversion Principle)
- 面向接口编程，依赖于抽象而不依赖于具体实现
- 要求我们在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类
- 使用方值关注接口而不关注具体类的实现
总结： 面向接口编程、面向抽象编程，关注接口而不关注具体类的实现（依赖抽象而不依赖于具体）

当你定义一个类的时候，会得到两个类型： 
- 类 的类型
- 实例 的类型 或者是 类的原型 的类型

## 设计模式
### 工厂模式
##### 简单工厂模式
- 简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例

##### 工厂方法模式
* 工厂方法模式 Factory Method, 又称为 多态性工厂模式
* 在工厂方法模式中，核心的工厂类不在负责所有的产品的创建，而是将具体创建的工作交给工厂子类去做

##### 抽象工厂模式
- 抽象工厂模式可以向客户端提供一个接口，使客户端在不必指定具体产品的具体的情况下，创建更多产品中的产品对象
- 抽象工厂模式针对的是同一类或同等级产品，而抽象工厂模式针对的是多种类的产品设计
- 系统中有多个产品族，每个具体工厂负责创建同一族但属于不提供产品登记（产品种类）的产品
- 产品族是一组相关或相互依赖的对象
- 系统一次只能消费某一族产品族时，只需要增加新的工厂类即可，无需修改源当代吗；但是如果需要产品族中新增一个新种类的产品时，则所有的工厂类的都需要修改

###### 组成角色
- 抽象工厂： 提供了创建产品的接口，包含多个创建产品的方法，即包含多个类似创建的产品方法
- 具体体工厂： 实现抽象工厂定义的接口，完成某个具体的创建
- 抽象产品： 抽象产品定义，一般有多少抽象产品，抽象工厂中就包含多个创建产品的方法
- 具体产品： 抽象产品的实现类

###